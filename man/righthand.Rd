% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/value-separator.R
\name{\%,\% (righthand side)}
\alias{\%,\% (righthand side)}
\alias{\%,\%}
\alias{rhs-separator}
\title{Value separator / infix appender}
\usage{
lhs \%,\% rhs
}
\arguments{
\item{lhs}{A value}

\item{rhs}{A value}
}
\value{
A list
}
\description{
In Python 3, users can use commas on the righthand side of assignments as well as the lefthand side. Using bare commas essentially creates tuples, where each element in the tuple was a value separated by the commas:

\preformatted{
a, b, c = "A", False, 99.0
a, b, *c = [1,2,3], "Z"
a = "A", False, [1,2,3]
"A", 1
}

If used anywhere other than the lefthand side of an assignment, \code{unpackr}'s infix separator \code{\link{\%,\%}} acts somewhat similarly, appending values separated by commas into a list (see Order of operations for caveat).
Unlike functions such as \link[base:append]{append()}, \code{\%,\%} will not unlist any of the arguments in its chain. Therefore \code{list("A") \%,\% list("B")} will return the equivalent of \code{list(list("A"), list("B"))} rather than \code{list("A", "B")}.
}
\section{Order of operations}{


When not on the lefthand side of an assignment, \code{\%,\%} follows the same order of operations as any other infix operator in R.  This means that if one wants to separate \emph{calls} rather simple values with \code{\%,\%}, it is highly recommended that one add parentheses around these calls.  See Examples for how this works.

For example, \code{"A" \%,\% 1 + 1 \%,\% "B"} will try to add \code{list("A",1)} to \code{list(1, "B")} and throw an error.
}

\section{Technical notes}{


Technically, \code{\%,\%} has \emph{four} arguments, not just \code{lhs} and \code{rhs}. These additional two values are internal and cannot be access via the normal \code{x \%,\% y} method of calling \code{\%,\%}. There is no reason to ever change them.
}

\examples{
# Replicating the Python examples above
a \%,\% b \%,\% c <- "A" \%,\%  FALSE \%,\% 99.0
a \%,\%  b \%,*\% c <- c(1, 2, 3) \%,\% "Z"
a <- "A" \%,\%  FALSE \%,\%  c(1, 2, 3)
"A" \%,\% 1

# `\%,\%` keeps the original shape of its values
list("A") \%,\% list("B")
# Unlike append():
append(list("A"), list("B"))

# These are all calls that will not work because
#   of R's order of operations:
\dontrun{
  "A" \%,\% TRUE || FALSE
  # If you have `magrittr` installed
  "A" \%,\% TRUE \%>\% xor(FALSE) \%,\% "B"
  "A" \%,\% 1 * 3 \%,\% "B"}

# Instead, use parentheses:
"A" \%,\% (TRUE || FALSE)
"A" \%,\% (1 * 3) \%,\% "B"
}
